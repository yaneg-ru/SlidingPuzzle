using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class GameManager : MonoBehaviour
{

  [SerializeField] private Transform gameTransform;
  [SerializeField] private Transform piecePrefab;

  private List<Transform> pieces;
  private int emptyLocation;
  private int size;
  private bool shuffling = false;

  // Create the game setup with size x size pieces.
  /// <summary>
  /// Создаёт поле головоломки размера <c>size x size</c>, инстанцируя префабы плиток
  /// и настраивая их позицию, масштаб и UV‑координаты для корректного отображения
  /// исходного изображения (текстуры). Последняя (нижняя правая) плитка делается
  /// пустой (отключается), и её индекс сохраняется в <see cref="emptyLocation"/>.
  ///
  /// Метод не выполняет проверку корректности поля <c>size</c> — предполагается,
  /// что оно уже задано в другом месте (например, в <see cref="Start"/>).
  /// </summary>
  /// <param name="gapThickness">
  /// Толщина зазора (в локальных координатах игрового поля) — используется для
  /// уменьшения видимого размера плитки и подрезки UV, чтобы между плитками
  /// был визуальный промежуток (в пикселях/единицах текстуры это задаётся
  /// относительным значением от размера плитки).
  /// </param>
  private void CreateGamePieces(float gapThickness)
  {
    // Ширина (в локальной системе координат игрового поля) одной плитки.
    // Поле нормируется от -1 до +1 по обеим осям, поэтому полная ширина поля = 2.
    // Делим 1 на size и используем 2*width при расчётах позиций — это позволяет
    // корректно вычислять центр каждой плитки.

    // Подробнее:
    // - Поле в локальных координатах занимает диапазон [-1, +1] по X (аналогично по Y),
    //   поэтому общая длина по оси = 2.
    // - Шаг между центрами соседних плиток равен 2/size. Для удобства мы вводим
    //   переменную width = 1 / size, тогда 2*width == 2/size — это именно шаг между
    //   центрами (distance between centers).
    // - Переменная width фактически соответствует «половине шага» или половине
    //   размера плитки в этих нормализованных координатах. Поэтому при вычислении
    //   центра плитки мы смещаемся на (2*width*col) от левой границы и затем добавляем
    //   width, чтобы попасть в центр клетки: -1 + (2*width*col) + width.
    // - Итоговый локальный размер плитки берётся как полный шаг между центрами
    //   минус толщина зазора: (2*width) - gapThickness.
    //
    // Пример (size = 3):
    // width = 1/3 ≈ 0.333..., шаг между центрами = 2*width = 2/3 ≈ 0.666...
    // колонки: col=0 → x = -1 + 0 + 1/3 = -2/3
    //          col=1 → x = -1 + 2/3 + 1/3 = 0
    //          col=2 → x = -1 + 4/3 + 1/3 = 2/3
    // Центры равномерно распределены по диапазону [-1,+1], каждый центр отстоит на 2/3.
    //
    // Таким образом использование width = 1/size и формул с 2*width даёт простую и
    // стабильную систему координат для размещения и масштабирования плиток.
    float width = 1 / (float)size;

    // Проходимся по строкам и столбцам, создаём плитки слева направо сверху вниз.
    for (int row = 0; row < size; row++)
    {
      for (int col = 0; col < size; col++)
      {
        // Создаём инстанс префаба плитки внутри контейнера gameTransform.
        Transform piece = Instantiate(piecePrefab, gameTransform);
        // Сохраняем ссылку в списке для управления состоянием игры.
        pieces.Add(piece);

        // Вычисляем позицию плитки. Игровое поле спроектировано так, что
        // координаты по X идут от -1 (левый край) до +1 (правый), а по Y от
        // +1 (верх) до -1 (низ). Для вычисления центра плитки используем
        // смещение ±width и шаг 2*width между центрами плиток.
        piece.localPosition = new Vector3(
          -1 + (2 * width * col) + width,
          +1 - (2 * width * row) - width,
          0);

        // Устанавливаем масштаб плитки так, чтобы между плитками оставался
        // небольшой зазор gapThickness. Мы уменьшаем размер плитки ровно на
        // величину зазора (учитывая что width —半 половина шага по координате),
        // поэтому итоговый размер = (2*width) - gapThickness.
        piece.localScale = ((2 * width) - gapThickness) * Vector3.one;

        // Присваиваем читаемое имя в виде индекса (row * size + col). Это
        // удобно для проверки завершения пазла в методе CheckCompletion().
        piece.name = $"{(row * size) + col}";

        // Делаем нижнюю правую плитку пустой — отключаем объект и сохраняем
        // её индекс в emptyLocation (последний индекс в массиве плиток).
        if ((row == size - 1) && (col == size - 1))
        {
          emptyLocation = (size * size) - 1;
          piece.gameObject.SetActive(false);
        }
        else
        {
          // Настраиваем UV‑координаты у меша плитки, чтобы каждая плитка
          // отображала правильную часть общей текстуры (спрайта/атласа).
          //
          // Замечание по системе координат UV: здесь UV ожидаются в диапазоне
          // [0,1] по обеим осям. Поскольку мы используем нормированную сетку
          // шириной width, левый край плитки = width*col, правый = width*(col+1),
          // верх = 1 - width*row, низ = 1 - width*(row+1) (учёт того, что в
          // экранных координатах Y идёт сверху вниз, а в UV Y=0 — низ текстуры).

          // Немного уменьшаем координаты UV на половину толщины зазора
          // (gap = gapThickness / 2), чтобы визуально создать пространство
          // между соседними плитками на итоговом рендере и избежать артефактов
          // семплинга по краям.
          float gap = gapThickness / 2;

          // Получаем Mesh плитки и создаём новый массив UV для 4 вершин.
          Mesh mesh = piece.GetComponent<MeshFilter>().mesh;
          Vector2[] uv = new Vector2[4];

          // Порядок UV вершин соответствует сетке меша префаба:
          // 0 -> верхний левый, 1 -> верхний правый, 2 -> нижний левый,
          // 3 -> нижний правый. Формулы ниже вычисляют координаты с учётом
          // gap для того, чтобы края плиток не перекрывались.
          //
          // 1 - (...) используется для инвертирования Y, т.к. UV Y=0 соответствует
          // нижней части текстуры, а row=0 у нас — верхняя строка.
          uv[0] = new Vector2((width * col) + gap, 1 - ((width * (row + 1)) - gap));
          uv[1] = new Vector2((width * (col + 1)) - gap, 1 - ((width * (row + 1)) - gap));
          uv[2] = new Vector2((width * col) + gap, 1 - ((width * row) + gap));
          uv[3] = new Vector2((width * (col + 1)) - gap, 1 - ((width * row) + gap));

          // Назначаем рассчитанные UV в меш. Это гарантирует, что каждая
          // плитка будет показывать нужную часть общей текстуры.
          mesh.uv = uv;
        }
      }
    }
  }

  // Start is called before the first frame update
  void Start()
  {
    pieces = new List<Transform>();
    size = 10;
    CreateGamePieces(0.01f);
  }

  /// <summary>
  /// Метод Update вызывается каждый кадр и выполняет следующие обязанности:
  /// 1) Проверяет, собран ли пазл (CheckCompletion). Если да — запускает корутину перемешивания
  ///    через короткую задержку (WaitShuffle), чтобы показать победу перед следующим тасованием.
  /// 2) Обрабатывает ввод мыши — одиночный клик левой кнопкой. Выполняется Raycast2D из
  ///    позиции курсора в мир и, если был попадание в плитку, пытается переместить её в пустую
  ///    ячейку проверяя четыре направления (вверх/вниз/влево/вправо).
  /// 
  /// Подробные замечания:
  /// - Переменная shuffling служит для того, чтобы не пытаться распознавать победу/перетасовывать
  ///   во время уже текущей операции тасовки.
  /// - SwapIfValid выполняет проверку корректности хода (включая предотвращение горизонтального
  ///   "оборачивания" через границу) и обновляет состояние pieces и emptyLocation при успешном ходе.
  /// - Raycast2D используется с направлением Vector2.zero потому, ///   что мы хотим получить попадание по точке (реже — можно было бы использовать Physics2D.OverlapPoint).
  /// - colCheck параметр для SwapIfValid ограничивает допустимые горизонтальные ходы (см. реализацию SwapIfValid).
  /// </summary>
  void Update()
  {
    // 1) Проверка завершения и запуск тасовки:
    // Если в текущий момент не происходит тасовка и пазл собран — помечаем shuffling=true
    // и запускаем корутину, которая через небольшой интервал вызовет Shuffle().
    if (!shuffling && CheckCompletion())
    {
      shuffling = true; // Блокируем повторный вход, пока идёт подготовка к тасовке.
      StartCoroutine(WaitShuffle(0.5f)); // Даем игроку полсекунды увидеть результат.
    }

    // 2) Обработка клика левой кнопкой мыши:
    // Реагируем только на нажатие, а не на удержание (GetMouseButtonDown(0)).
    if (Input.GetMouseButtonDown(0))
    {
      // Преобразуем экранные координаты курсора в координаты мира и выполняем Raycast2D.
      // Vector2.zero указывает, что луч — это по сути проверка точки.
      RaycastHit2D hit = Physics2D.Raycast(Camera.main.ScreenToWorldPoint(Input.mousePosition), Vector2.zero);

      // Если Raycast обнаружил объект (попадание в Collider) — продолжаем.
      if (hit)
      {
        // Проходим по списку плиток. Индекс в списке соответствует позиции в логическом поле.
        // Это позволяет сопоставлять позицию плитки с пустой ячейкой (emptyLocation).
        for (int i = 0; i < pieces.Count; i++)
        {
          // Сравниваем Transform плитки в списке с Transform'ом, в который попал Raycast.
          // Если это та самая плитка — пытаемся совершить ход в 4 направления.
          if (pieces[i] == hit.transform)
          {
            // Пояснение по параметрам SwapIfValid:
            // - offset — смещение индекса в списке (например, -size — вверх, +size — вниз, -1/+1 — влево/вправо).
            // - colCheck — ограничивающий параметр для предотвращения "оборачивания" по горизонтали.
            //
            // Проверяем направления в порядке: вверх, вниз, влево, вправо.
            // При первом успешном обмене прерываем цикл, чтобы не совершать несколько обменов за один клик.
            if (SwapIfValid(i, -size, size)) { break; }       // попытка переместиться вверх (row-1)
            if (SwapIfValid(i, +size, size)) { break; }       // попытка переместиться вниз  (row+1)
            if (SwapIfValid(i, -1, 0)) { break; }             // попытка переместиться влево  (col-1)
            if (SwapIfValid(i, +1, size - 1)) { break; }      // попытка переместиться вправо (col+1)
            // Примечание: порядок проверок не критичен, но важно, что мы выходим после первого успеха.
          }
        }
      }
    }
  }

  /// <summary>
  /// Пытается выполнить обмен плитки в позиции <paramref name="i"/> с плиткой, находящейся
  /// на позиции <c>i + offset</c>, если это допустимый ход в текущем состоянии поля.
  /// 
  /// Метод возвращает true только в случае успешного обмена (т.е. когда соседняя ячейка
  /// действительно является пустой), в противном случае возвращает false.
  /// 
  /// Особенности и ограничения:
  /// - Параметр <paramref name="offset"/> задаёт смещение в списке pieces:
  ///   вверх = -size, вниз = +size, влево = -1, вправо = +1.
  /// - Параметр <paramref name="colCheck"/> используется для предотвращения горизонтального
  ///   "оборачивания" при перемещениях влево/вправо. Для горизонтального хода метод
  ///   проверяет, что (i % size) != colCheck — это гарантирует, что мы не пересекаем
  ///   границу строки при попытке смещения на ±1.
  /// 
  /// Пример использования:
  /// - SwapIfValid(i, -1, 0) — попытка сдвинуть плитку влево (запрещено, если i%size == 0).
  /// - SwapIfValid(i, +1, size-1) — попытка сдвинуть плитку вправо (запрещено, если i%size == size-1).
  /// </summary>
  /// <param name="i">Индекс плитки в списке pieces, которую мы пытаемся переместить.</param>
  /// <param name="offset">Смещение для поиска целевой (соседней) ячейки.</param>
  /// <param name="colCheck">
  /// Значение для проверки столбца, используемое для предотвращения горизонтального оборачивания.
  /// Для вертикальных ходов это поле обычно равно size (и проверка по модулю не препятствует ходу).
  /// </param>
  private bool SwapIfValid(int i, int offset, int colCheck)
  {
    // Входная проверка состоит из двух частей:
    // 1) ((i % size) != colCheck) — предотвращает "склеивание" строк при горизонтальных смещениях.
    //    Для вертикальных смещений colCheck задан равным size, поэтому (i%size)!=size всегда true.
    // 2) ((i + offset) == emptyLocation) — проверяет, что целевая ячейка действительно пустая.
    if (((i % size) != colCheck) && ((i + offset) == emptyLocation))
    {
      // Обмен в состоянии игры: меняем позиции в списке pieces, чтобы логика отражала новый порядок.
      (pieces[i], pieces[i + offset]) = (pieces[i + offset], pieces[i]);

      // Обмен локальных позиций (Transform) у соответствующих объектов, чтобы визуально
      // отобразить перемещение плиток на сцене.
      (pieces[i].localPosition, pieces[i + offset].localPosition) = ((pieces[i + offset].localPosition, pieces[i].localPosition));

      // Обновляем индекс пустой ячейки — теперь она находится в позиции i (туда переместилась плитка).
      emptyLocation = i;

      // Возвращаем true, сигнализируя об успешном ходе.
      return true;
    }

    // Если любое из условий не выполнено — ход недопустим.
    return false;
  }

  // We name the pieces in order so we can use this to check completion.
  private bool CheckCompletion()
  {
    for (int i = 0; i < pieces.Count; i++)
    {
      if (pieces[i].name != $"{i}")
      {
        return false;
      }
    }
    return true;
  }

  private IEnumerator WaitShuffle(float duration)
  {
    yield return new WaitForSeconds(duration);
    Shuffle();
    shuffling = false;
  }

  /// <summary>
  /// Перемешивает поле плиток «в лоб», выполняя большое количество случайных
  /// допустимых перемещений. Метод не пытается гарантировать достижимость
  /// конкретного состояния — он просто выполняет последовательность реальных
  /// (валидных) ходов, начиная с текущего расположения плиток.
  /// 
  /// Поведение и сокращения:
  /// - count: считает число выполненных перемещений; цикл продолжается до тех пор,
  ///   пока count не станет равным size*size*size (эмпирная длина перемешивания).
  /// - last: служит для попытки избежать немедленного "отмены" предыдущего хода;
  ///   сравнивается с rnd (случайно выбранной позицией). Обратите внимание: в
  ///   текущей реализации last обновляется значением emptyLocation после проверки,
  ///   что обеспечивает простое ограничение на повторение одного и того же выбора.
  /// - rnd: случайный индекс от 0 до size*size-1, представляющий выбранную для
  ///   проверки плитку.
  /// 
  /// Алгоритм:
  /// 1) Пока не выполнено требуемое число перемещений:
  ///    a) выбираем случайный индекс rnd.
  ///    b) если rnd равен last — пропускаем итерацию (чтобы не сразу отменять предыдущий выбор).
  ///    c) сохраняем текущее местоположение пустой клетки в last.
  ///    d) пробуем выполнить один из четырёх возможных обменов относительно rnd:
  ///       вверх (-size), вниз (+size), влево (-1), вправо (+1).
  ///       Для каждого направления вызывается SwapIfValid — при первом успешном обмене
  ///       увеличиваем счётчик count и переходим к следующей итерации.
  /// 
  /// Замечания по качеству перемешивания:
  /// - Такая схема выполняет только реальные перемещения плиток (нет искусственной
  ///   перестановки ссылок без смещения), поэтому итог всегда достижим от исходного состояния.
  /// - Параметр длины (size*size*size) выбран как простая эвристика; при необходимости
  ///   можно изменить его для увеличения/уменьшения степени перемешанности.
  /// </summary>
  private void Shuffle()
  {
    int count = 0; // Сколько успешных перемещений уже выполнено.
    int last = 0;  // Используется для попытки избежать немедленного повторного выбора той же позиции.

    // Цикл выполняется пока не будет сделано достаточное число реальных перемещений.
    while (count < (size * size * size))
    {
      // Выбираем случайную позицию (индекс плитки) в диапазоне [0, size*size).
      int rnd = Random.Range(0, size * size);

      // Если случайно выбранная позиция совпала с last, пропускаем итерацию.
      // Это простая защита от мгновенного "отката" — уменьшает частоту ситуаций,
      // когда ход сразу же отменяется следующим случайным выбором.
      if (rnd == last) { continue; }

      // Обновляем last текущим положением пустой ячейки. После этого мы попытаемся
      // выполнить обмены вокруг rnd; если один из них сработает — count увеличится.
      last = emptyLocation;

      // Пытаемся выполнить допустимый обмен в четырёх направлениях вокруг rnd.
      // SwapIfValid вернёт true только если выбранное смещение ведёт к пустой ячейке
      // и не нарушает правила «оборачивания» горизонтальных перемещений.
      if (SwapIfValid(rnd, -size, size))
      {
        // Успешный ход вверх: учёт выполненного перемещения.
        count++;
      }
      else if (SwapIfValid(rnd, +size, size))
      {
        // Успешный ход вниз.
        count++;
      }
      else if (SwapIfValid(rnd, -1, 0))
      {
        // Успешный ход влево.
        count++;
      }
      else if (SwapIfValid(rnd, +1, size - 1))
      {
        // Успешный ход вправо.
        count++;
      }

      // Если ни один SwapIfValid не сработал — просто повторяем цикл с новым rnd.
      // Таким образом перемешивание состоит только из реальных допустимых перемещений.
    }
  }
}

